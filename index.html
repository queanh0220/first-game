<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title></title>
	<style type="text/css">
		* { padding: 0; margin: 0; }
		canvas { background: #eee; display: block; margin: 0 auto; }
		html,body { height: 100%;  overflow: hidden; }
	</style>
</head>
<body>
	<canvas id="myCanvas" width = "500" height = "350"></canvas>
	<script type="text/javascript">
		var canvas = document.getElementById("myCanvas");
		var ctx = canvas.getContext("2d");
		canvas.width = document.body.clientWidth
		canvas.height  = document.body.clientHeight
		const colors = [
		  "#f90707",
		  "#ffeb3b",
		  "#59ff3b",
		  "#3bfff6",
		  "#1a20e5",
		  "#f919e8",
		  "#744967",
		  "#7cffd5",
		  "#9fa3a2",
		];
		var lives = 2;
		var score = 0;
		var idcolor = 0;
		var x = canvas.width/2, y = canvas.height-50;
		var ballRadius = 12;
		var dx =50; dy = -50;

		var then = Date.now(),fpsInterval = 1000/50, now, elapsed = 2;

		var paddleHeight = 20, paddleWidth = 150;
		var paddleX = (canvas.width - paddleWidth) / 2;
		var rightPressed = false;
		var leftPressed = false;

		var brickRowCount = 3;
		var brickColumnCount = 5;
		var brickHeight = 20;
		var brickPadding = 10;
		var brickOffsetTop = 30;
		var brickOffsetLeft = 30;
		var brickWidth = (canvas.width - brickPadding*(brickColumnCount-1)-brickOffsetLeft*2)/brickColumnCount; 

		var bricks = [];
		for(var c=0; c<brickColumnCount; c++) {
		    bricks[c] = [];
		    for(var r=0; r<brickRowCount; r++) {
		        bricks[c][r] = { x: 0, y: 0, status: true };
		    }
		}

		document.addEventListener("keydown", keyDownHandler, false);
		document.addEventListener("keyup", keyUpHandler, false);
		document.addEventListener("mousemove", mouseMoveHandler, false);
		document.addEventListener("touchmove", touchmoveHandler, false);

		function drawLives() {
		    ctx.font = "16px Arial";
		    ctx.fillStyle = "#0095DD";
		    ctx.fillText("Lives: "+lives, canvas.width-65, 20);
		}

		function drawScore() {
			ctx.font = "16px Arial";
			ctx.fillStyle = "#0095DD";
			ctx.fillText("Score: "+score, 8, 20);
		}

		function drawBall(){
			ctx.beginPath();
			ctx.arc(x,y,ballRadius,0,Math.PI*2,false);
			ctx.fillStyle = colors[idcolor];
			ctx.fill();
			ctx.closePath();
		}

		function drawPaddle(){
			ctx.beginPath();
			ctx.rect(paddleX,canvas.height - paddleHeight, paddleWidth, paddleHeight);
			ctx.fillStyle = "blue";
			ctx.fill();
			ctx.closePath();
		}

		function drawBrick(){
			 for(var c=0; c<brickColumnCount; c++) {
		        for(var r=0; r<brickRowCount; r++) {
		        	if(bricks[c][r].status) {
		        		var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
			            var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
			            bricks[c][r].x = brickX;
			            bricks[c][r].y = brickY;
			            ctx.beginPath();
			            ctx.rect(brickX, brickY, brickWidth, brickHeight);
			            ctx.fillStyle = "blue";
			            ctx.fill();
			            ctx.closePath();
		        	}
		        }
		    }
		}

		function draw(){
			//then = Date.now();
			ctx.clearRect(0, 0, canvas.width,canvas.height);
			drawBall();
			drawPaddle();
			drawBrick();
			drawScore();
			drawLives();
			checkCollision();
			//alert(elapsed);
			x += dx*(1/elapsed);
			y += dy*(1/elapsed);
			requestAnimationFrame(draw);
			now = Date.now();
			elapsed = now - then;
			if (elapsed > fpsInterval) {

		        // Get ready for next frame by setting then=now, but also adjust for your
		        // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
		        then = now - (elapsed % fpsInterval);

		        // Put your drawing code here

		    }
		}

		function checkCollision(){
			if(x + dx*(1/elapsed) < ballRadius || x + dx*(1/elapsed) > canvas.width - ballRadius){
				dx = -dx;
				idcolor++;
			} 
			if(y + dy*(1/elapsed) < ballRadius){
				dy = -dy;
				idcolor++;
			} 
			if(y + dy*(1/elapsed) > canvas.height - ballRadius - paddleHeight) {
				if( cirRecColection(x + dx*(1/elapsed),y + dx*(1/elapsed),paddleX,canvas.height - paddleHeight,paddleWidth,paddleHeight) ) {
					x += dx*(1/elapsed) ;y += dy*(1/elapsed);
					ctx.clearRect(0, 0, canvas.width,canvas.height);
					drawBall();
					drawPaddle();
					drawBrick();
					drawScore();
					drawLives();
					x -= dx*(1/elapsed); y -= dy*(1/elapsed);
					if(x + dx*(1/elapsed) < paddleX || x + dx*(1/elapsed) > paddleX + paddleWidth)dx = -dx;
					dy = -dy;
					idcolor++;
				}
			}
			if(y + dy*(1/elapsed) > canvas.height - ballRadius) {
				x += dx*(1/elapsed) ;y += dy*(1/elapsed);
				ctx.clearRect(0, 0, canvas.width,canvas.height);
				drawBall();
				drawPaddle();
				drawBrick();
				drawScore();
				drawLives();
				x -= dx*(1/elapsed); y -= dy*(1/elapsed);
				lives--;
					if(!lives) {
					    alert("GAME OVER\nYOUR SCORE: "+score);
						//document.location.read();
						//clearInterval(interval);
					}
					else {
					    x = canvas.width/2;
					    y = canvas.height-50;
					    dx = -50;
					    dy = -50;
					    paddleX = (canvas.width-paddleWidth)/2;
					}
			}
			
			
			if(rightPressed) {
		        paddleX += 10;
		        if (paddleX + paddleWidth > canvas.width){
		            paddleX = canvas.width - paddleWidth;
		        }
		    }
		    else if(leftPressed) {
		        paddleX -= 10;
		        if (paddleX < 0){
		            paddleX = 0;
		        }
		    }

		    for(var c=0; c<brickColumnCount; c++) {
		        for(var r=0; r<brickRowCount; r++) {
		            var b = bricks[c][r];
		            if(b.status == 1) {
		                if(cirRecColection(x,y,b.x,b.y,brickWidth,brickHeight)) {
		                    dy = -dy;
		                    idcolor++;
		                    b.status = 0;
		                    score+=100;
		                    if(score/100 == brickRowCount*brickColumnCount) {
		                        alert("YOU WIN!\nYOUR SCORE: "+score);
		                        document.location.reload();
		                       // clearInterval(interval);
                    		}
		                }
		            }
		        }
		    }

		    if(idcolor > colors.length-1)idcolor = 0;
		}

		function cirRecColection(xc, yc, xr, yr,weigth,height)
		{
			var xa = xc, ya = yc;
			if(xc < xr)xa = xr;
			else if(xc > xr+weigth) xa = xr+weigth;
			if(yc < yr)ya = yr;
			else if(yc > yr+height) ya = yr+height;
			return ((xc-xa)*(xc-xa)+(yc-ya)*(yc-ya)) <= ballRadius*ballRadius;
		}


		function keyDownHandler(e) {
			if(e.key == "Right" || e.key == "ArrowRight") {
				rightPressed = true;
			}
			else if(e.key == "Left" || e.key == "ArrowLeft") {
				leftPressed = true;
			}
		}

		function keyUpHandler(e) {
		    if(e.key == "Right" || e.key == "ArrowRight") {
		        rightPressed = false;
		    }
		    else if(e.key == "Left" || e.key == "ArrowLeft") {
		        leftPressed = false;
		    }
		}

		function mouseMoveHandler(e) {
		    var relativeX = e.clientX - canvas.offsetLeft;
		    if(relativeX > 0 && relativeX < canvas.width) {
		        paddleX = relativeX - paddleWidth/2;
		    }
		}

		function touchmoveHandler(e) {
			 for (var i = 0; i < e.touches.length; i++) {

			 	var relativeX = e.touches[i].clientX - canvas.offsetLeft;
			if(relativeX > 0 && relativeX < canvas.width) {
		        paddleX = relativeX - paddleWidth/2;
		    }
			 }
		}
	draw();
	//	var interval = setInterval(draw,10);
	</script>
</body>
</html>
